package fs;

import fs.ast.*;
import fs.ast.expresion.*;
import fs.ast.expresion.operacion.*;
import fs.ast.simbolos.*;
import fs.ast.instruccion.*;
import fs.ast.instruccion.condicionales.*;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;

parser code
{:
	private AST ast;
	
	public AST getAST(){
		return ast;
	}
	
    @Override
    public void syntax_error(Symbol s){
        System.out.println("Error Sintactico en la Linea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador " +s.value + " no reconocido." );
		//AnalizadorError tmp = new AnalizadorError();
		//tmp.setColumna(s.right+1);
		//tmp.setLinea(s.left+1);
		//tmp.setValor(s.value+"");
		//tmp.setError("Sint√°ctico");
        
		//error.add(tmp);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error Sintactico Fatal en la Linea " + (s.right+1)+ " Columna "+(s.left+1)+". Identificador " + s.value + " no reconocido.");
		//report_fatal_error("Error sintactico: <"+s.value+">", cur_token);
	}
:}

action code
{:

:}

terminal String tstring, tchar, entero, decimal, identificador, nulo_, verdadero_, falso_;
terminal llaveIzquierda, llaveDerecha, parIzquierda, parDerecha, corcheteIzquierda, corcheteDerecha, puntoycoma, coma, punto;
terminal dospuntos, interrogacion;
terminal mas, menos, asterisco, diagonal, potencia, umenos, umas, masmas, menosmenos;
terminal mayorque, menorque, mayorigual, menorigual, igualigual, diferente;
terminal and, or, not;
terminal igual, masigual, menosigual, porigual, diagonaligual;
terminal var_, imprimir_, importar_, detener_, retornar_, si_, sino_, selecciona_, caso_, defecto_, funcion_;

non terminal INICIO, OP_ASIGNACION;
non terminal IMPORTAR;
non terminal LLAMADA_METODOS;

non terminal LinkedList<NodoAST> INSTRUCCIONES;
non terminal NodoAST INSTRUCCION;
non terminal Declaracion DECLARACION;
non terminal LinkedList<Asignacion> SEMIDECLARACION;
non terminal Asignacion ASIGNA;
non terminal Asignacion ASIGNACION;
non terminal Imprimir IMPRIMIR;
non terminal LinkedList<NodoAST> BLOQUES;
non terminal NodoAST BLOQUE;
non terminal Si SI;
non terminal SubSi SINO;
non terminal LinkedList<SubSi> SINOSI;
non terminal Selecciona SELECCIONA;
non terminal LinkedList<Caso> CASOS;
non terminal Caso CASO;
non terminal Funcion FUNCION;
non terminal LinkedList<String> PARAMETROS;
non terminal LinkedList<String> PARAMETRO;
non terminal LinkedList<Expresion> EXS;
non terminal LinkedList<Expresion> PARMS;
non terminal LlamadaFuncion LLAMADA_METODO;
non terminal Map<String, Expresion> OBJS;
non terminal Unario UNARIO;
non terminal Expresion E;

precedence left interrogacion;
precedence left or;
precedence left and;
precedence right not;
precedence left igualigual;
precedence left diferente;
precedence left mayorque, menorque, mayorigual, menorigual;
precedence left mas, menos;
precedence left asterisco, diagonal;
precedence right potencia;
precedence right masmas, menosmenos;
precedence right umenos, umas;

start with INICIO;

INICIO ::= INSTRUCCIONES:a 
		{:
			parser.ast = new AST(a);
            System.out.println("FS OK");
			
		:};
		
INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b{:RESULT = a; RESULT.add(b);:}
				| INSTRUCCION:a{:RESULT = new LinkedList<>(); RESULT.add(a);:};

INSTRUCCION ::= DECLARACION:a puntoycoma{:RESULT = a;:}
				|ASIGNACION:a puntoycoma{:RESULT = a;:}
				|IMPRIMIR:a puntoycoma{:RESULT = a;:}
				|IMPORTAR:a puntoycoma{::}
				|SI:a {:RESULT = a;:}
				|SELECCIONA:a {:RESULT = a;:}
				|FUNCION:a {:RESULT = a;:}
				|LLAMADA_METODO:a puntoycoma{:RESULT = a;:}
				|LLAMADA_METODOS:a puntoycoma{::}
				|UNARIO:a puntoycoma{:RESULT = a;:};
				
ASIGNACION ::=identificador:a OP_ASIGNACION:o E:b{: RESULT = new Asignacion(a, b, oleft+1, oright+1); :}
			| identificador:a punto identificador:b OP_ASIGNACION:c E:d{:RESULT = new AsignacionObjeto(a, b, d, aleft+1, aright+1);:}
			| identificador:a punto identificador:b corcheteIzquierda E:c corcheteDerecha OP_ASIGNACION:d E:e{:RESULT = new AsignacionObjeto(a, b, c, e, aleft+1, aright+1);:}
			| identificador:a corcheteIzquierda E:b corcheteDerecha OP_ASIGNACION:c E:d{:RESULT = new AsignacionArreglo(a, b, d, aleft+1, aright+1);:};

				
DECLARACION ::= var_:x SEMIDECLARACION:a{:RESULT = new Declaracion(a, xleft+1, xright+1);:};

SEMIDECLARACION ::= SEMIDECLARACION:a coma ASIGNA:b{:RESULT = a; RESULT.add(b);:}
				| ASIGNA:a{:RESULT = new LinkedList<>(); RESULT.add(a);:};
				
ASIGNA ::= identificador:a {:RESULT = new Asignacion(a, aleft+1, aright+1);:}
		| identificador:a OP_ASIGNACION:o E:b{:RESULT = new Asignacion(a, b, aleft+1, aright+1);:};

OP_ASIGNACION ::= igual {::}
				| masigual{::}
				| menosigual{::}
				| porigual{::}
				| diagonaligual{::};

EXS ::= EXS:a coma E:b {:RESULT = a; RESULT.add(b);:}
		|E:a{:RESULT = new LinkedList<>(); RESULT.add(a);:};	
			
OBJS ::= OBJS:a coma identificador:b dospuntos E:c{:RESULT = a; RESULT.put(b, c);:}
		|identificador:a dospuntos E:b{:RESULT = new HashMap<String, Expresion>(); RESULT.put(a, b);:};

IMPRIMIR ::= imprimir_:x parIzquierda parDerecha{:RESULT = new Imprimir(null, xleft+1, xright+1);:}
			|imprimir_:x parIzquierda E:a parDerecha{:RESULT = new Imprimir(a, xleft+1, xright+1);:};

IMPORTAR ::= importar_ parIzquierda parDerecha{::}
			|importar_ parIzquierda E:a parDerecha{::};

BLOQUES ::= BLOQUES:a BLOQUE:b {:RESULT = a; RESULT.add(b);:}
			|BLOQUE:a {:RESULT = new LinkedList<>(); RESULT.add(a);:};
			
			
BLOQUE ::= DECLARACION:a puntoycoma{:RESULT = a;:}
		|ASIGNACION:a puntoycoma{:RESULT = a;:}
		|IMPRIMIR:a puntoycoma{:RESULT = a;:}
		|IMPORTAR:a puntoycoma{::}
		| detener_:x puntoycoma{:RESULT = new Detener(xleft+1, xright+1);:}
		| retornar_:x E:a puntoycoma{:RESULT = new Retornar(a, xleft+1, xright+1);:}
		|SI:a {:RESULT = a;:}
		|SELECCIONA:a {:RESULT = a;:}
		|LLAMADA_METODO:a puntoycoma{:RESULT = a;:}
		|LLAMADA_METODOS:a puntoycoma{::}
		|UNARIO:a puntoycoma{:RESULT = a;:};


SI ::= si_:x parIzquierda E:a parDerecha llaveIzquierda BLOQUES:b llaveDerecha
			{:RESULT = new Si(a, b, xleft+1, xright+1);:}
		|si_:x parIzquierda E:a parDerecha llaveIzquierda BLOQUES:b llaveDerecha 	SINO:c
			{:RESULT = new Si(a, b, xleft+1, xright+1, c);:}
		|si_:x parIzquierda E:a parDerecha llaveIzquierda BLOQUES:b llaveDerecha SINOSI:c
			{:RESULT = new Si(a, b, xleft+1, xright+1, c);:}
		|si_:x parIzquierda E:a parDerecha llaveIzquierda BLOQUES:b llaveDerecha SINOSI:c SINO:d
			{:RESULT = new Si(a, b, xleft+1, xright+1, c, d);:};

SINO ::= sino_:x llaveIzquierda BLOQUES:a llaveDerecha{:RESULT = new SubSi(a, xleft+1, xright+1);:};
		
SINOSI ::= SINOSI:a sino_:x si_ parIzquierda E:b parDerecha llaveIzquierda BLOQUES:c llaveDerecha
			{:RESULT = a; RESULT.add(new SubSi(b, c, xleft+1, xright+1));:}
		| sino_:x si_ parIzquierda E:a parDerecha llaveIzquierda BLOQUES:b llaveDerecha
			{:RESULT = new LinkedList<>(); RESULT.add(new SubSi(a, b, xleft+1, xright+1));:};

SELECCIONA ::= selecciona_:x parIzquierda E:a parDerecha llaveIzquierda CASOS:b llaveDerecha{:RESULT = new Selecciona(a, b, xleft+1, xright+1);:};
			
CASOS ::= CASOS:a CASO:b{:RESULT = a; RESULT.add(b);:}
		| CASO:a {:RESULT = new LinkedList<>(); RESULT.add(a);:};
		
CASO ::= caso_:x E:a dospuntos llaveIzquierda BLOQUES:b llaveDerecha{:RESULT = new Caso(a, b, xleft+1, xright+1);:}
		|defecto_:x dospuntos llaveIzquierda BLOQUES:a llaveDerecha{:RESULT = new Caso(a, xleft+1, xright+1);:};

FUNCION ::= funcion_:x identificador:a parIzquierda PARAMETROS:b parDerecha llaveIzquierda BLOQUES:c llaveDerecha
			{:RESULT = new Funcion(a, b, c, xleft+1, xright+1);:}
		| funcion_:x identificador:a parIzquierda parDerecha llaveIzquierda BLOQUES:c llaveDerecha
			{:RESULT = new Funcion(a, c, xleft+1, xright+1);:};

PARAMETROS ::= PARAMETRO:a {:RESULT = a;:};
			
PARAMETRO ::= PARAMETRO:a coma var_ identificador:b {:RESULT = a; RESULT.add(b);:}
			| var_ identificador:a{:RESULT = new LinkedList<>(); RESULT.add(a);:};
			
LLAMADA_METODO ::= identificador:a parIzquierda PARMS:b parDerecha
					{:
						if(b != null){
							RESULT = new LlamadaFuncion(a, b, aleft+1, aright+1);
						} else {
							RESULT = new LlamadaFuncion(a, b, aleft+1, aright+1);
						}
					:};

LLAMADA_METODOS ::=LLAMADA_METODOS:c punto identificador:a parIzquierda PARMS:b parDerecha{::}
				|identificador:a punto identificador:b parIzquierda PARMS:c parDerecha{::};

PARMS ::= {:RESULT=null;:}
		| EXS:a{:RESULT = a;:};

UNARIO ::= E:a masmas{:RESULT = new Unario(a, Operacion.Operador.AUMENTO, aleft+1, aright+1);:}
		| E:a menosmenos{:RESULT = new Unario(a, Operacion.Operador.DECREMENTO, aleft+1, aright+1);:};
		
E ::= 	  menos:x E:a {:RESULT = new Aritmetica(a, Operacion.Operador.MENOS, xleft+1, xright+1);:} %prec umenos
	|     mas:x E:a {:RESULT = new Aritmetica(a, Operacion.Operador.MAS, xleft+1, xright+1);:} %prec umas
	| E:a mas:x E:b{:RESULT = new Aritmetica(a, b, Operacion.Operador.MAS, xleft+1, xright+1);:}
	| E:a menos:x E:b{:RESULT = new Aritmetica(a, b, Operacion.Operador.MENOS, xleft+1, xright+1);:}
	| E:a asterisco:x E:b{:RESULT = new Aritmetica(a, b, Operacion.Operador.ASTERISCO, xleft+1, xright+1);:}
	| E:a diagonal:x E:b{:RESULT = new Aritmetica(a, b, Operacion.Operador.BARRA, xleft+1, xright+1);:}
	| E:a potencia:x E:b{:RESULT = new Aritmetica(a, b, Operacion.Operador.INTERCALACION, xleft+1, xright+1);:}
	| E:a masmas:x{:RESULT = new Aritmetica(a, Operacion.Operador.AUMENTO, xleft+1, xright+1);:}
	| E:a menosmenos:x{:RESULT = new Aritmetica(a, Operacion.Operador.DECREMENTO, xleft+1, xright+1);:}
	| E:a mayorque:x E:b{:RESULT = new Relacional(a, b, Operacion.Operador.MAYORQUE, xleft+1, xright+1);:}
	| E:a menorque:x E:b{:RESULT = new Relacional(a, b, Operacion.Operador.MENORQUE, xleft+1, xright+1);:}
	| E:a mayorigual:x E:b{:RESULT = new Relacional(a, b, Operacion.Operador.MAYORIGUALQUE, xleft+1, xright+1);:}
	| E:a menorigual:x E:b{:RESULT = new Relacional(a, b, Operacion.Operador.MENORIGUALQUE, xleft+1, xright+1);:}
	| E:a igualigual:x E:b{:RESULT = new Relacional(a, b, Operacion.Operador.IGUAL, xleft+1, xright+1);:}
	| E:a diferente:x E:b{:RESULT = new Relacional(a, b, Operacion.Operador.DIFERENTE, xleft+1, xright+1);:}
	| E:a and:x E:b{:RESULT = new Logica(a, b, Operacion.Operador.AND, xleft+1, xright+1);:}
	| E:a or:x E:b{:RESULT = new Logica(a, b, Operacion.Operador.OR, xleft+1, xright+1);:}
	| not:x E:a{:RESULT = new Logica(a, xleft+1, xright+1);:}
	| tstring:a{:RESULT = new Literal(Tipo.CADENA, a, aleft+1, aright+1);:}
	| tchar:a{:RESULT = new Literal(Tipo.CADENA, a, aleft+1, aright+1);:}
	| entero:a{:RESULT = new Literal(Tipo.ENTERO, new Integer(a), aleft+1, aright+1);:}
	| decimal:a{:RESULT = new Literal(Tipo.DECIMAL, new Double(a), aleft+1, aright+1);:}
	| identificador:a{:RESULT = new Identificador(a, aleft+1, aright+1);:}
	| nulo_:a{:RESULT = new Literal(Tipo.NULL, "nulo", aleft+1, aright+1);:}
	| verdadero_:a{:RESULT = new Literal(Tipo.BOOLEANO, "verdadero", aleft+1, aright+1);:}
	| falso_:a{:RESULT = new Literal(Tipo.BOOLEANO, "falso", aleft+1, aright+1);:}
	| parIzquierda E:a parDerecha{:RESULT = a;:}
	| identificador:a punto identificador:b{:RESULT = new AccesoObjeto(a, b, aleft+1, aright+1);:}
	| identificador:a punto identificador:b corcheteIzquierda E:c corcheteDerecha{:RESULT = new AccesoObjeto(a, b, c, aleft+1, aright+1);:}
	| identificador:a corcheteIzquierda E:b corcheteDerecha{:RESULT = new AccesoArreglo(a, b, aleft+1, aright+1);:}
	| E:a interrogacion:x E:b dospuntos E:c{:RESULT = new Ternario(a, b, c, xleft+1, xright+1);:}
	| corcheteIzquierda:x EXS:a corcheteDerecha{:RESULT = new Literal(Tipo.ARREGLO, a, xleft+1, xright+1);:}
	| llaveIzquierda:x OBJS:a llaveDerecha{:RESULT = new Literal(Tipo.OBJETO, a, xleft+1, xright+1);:}
	| corcheteIzquierda:x corcheteDerecha{:RESULT = new Literal(Tipo.ARREGLO, null, xleft+1, xright+1);:}
	| llaveIzquierda:x llaveDerecha{:RESULT = new Literal(Tipo.OBJETO, null, xleft+1, xright+1);:}
	|LLAMADA_METODO:a {:RESULT = a;:}
	|LLAMADA_METODOS:a {::};
		
		
		